
*****These are all functions from Area.c*****

static int _create_loot(Area *this, struct SDL_Renderer *renderer)
{
    int i, rand_index, rand_x, rand_y;
    this->loot = CREATE_BAG();
    this->loot->items = malloc(sizeof(char *) * this->num_chests);
    this->loot_cords_x = malloc(sizeof(int) * this->num_chests);
    this->loot_cords_y = malloc(sizeof(int) * this->num_chests);
    this->loot_collidables = malloc(sizeof(Collidable *) * this->num_chests);

    rand_index = 0;;
    rand_x = 0;
    rand_y = 0;

    for (i = 0; i < this->num_chests; i++)
    {
        this->randomize_loot_locations(this, &rand_x, &rand_y);
        this->loot_cords_x[i] = rand_x;
        this->loot_cords_y[i] = rand_y;
        rand_index = (rand() % ITEM_QUANTITY);
        this->loot->items[i] = malloc(strlen(ITEMS[rand_index]) + 1);
        strcpy(this->loot->items[i], ITEMS[rand_index]);
        this->loot_collidables[i] = CREATE_COLLIDABLE(CHEST);
        this->loot_collidables[i]->make_chest(this->loot_collidables[i], renderer, rand_x, rand_y, 16, 16);
        printf("\nAdding %s to area loot collection. at index %d.", this->loot->items[i], i);
    }
    return this->num_chests;
}
static void _create_npcs(Area *this, struct SDL_Renderer *renderer)
{
    int i;
    this->npc_collidables = malloc(sizeof(Collidable *) * this->num_npcs);
    this->loot_cords_x = malloc(sizeof(int) * this->num_npcs);
    this->loot_cords_y = malloc(sizeof(int) * this->num_npcs);

    for (i = 0; i < this->num_npcs; i++)
    {
        this->loot_cords_x[i] = 350;
        this->loot_cords_y[i] = 350;
        this->npc_collidables[i] = CREATE_COLLIDABLE(NPC);
        this->npc_collidables[i]->make_npc(this->npc_collidables[i], renderer, this->loot_cords_x[i], this->loot_cords_y[i], 72, 111, "graphics/giga.png");
    }
}
static void _randomize_loot_locations(Area *this, int *x, int *y)
{
    int neg = 1;

    if (rand() % 1)
    {
        neg = -1;
    }

    *x = (rand() % (this->map_w - WINDOW_WIDTH)) * neg;
    *y = (rand() % (this->map_h - WINDOW_HEIGHT)) * (neg * neg);
}

******from render_area function****

    if ((-1) != (item_to_be_obtained = this->loot_collidables[0]->collistion(this->loot_collidables)))
    {
        strcpy(dungeon_message, "LOOTED ");
        strcat(dungeon_message, ((const char *)bag->loot(bag, this->loot->get_enum(this->loot, item_to_be_obtained))));
        printf("\n(");
        for (int k = 0; k < 4; k++)
        {
            printf(" %d,", bag->item_quantities[k]);
        }
        refresh_inputs(USER_INPUTS, 6, 1);
        previous_state = this->area_key;
        state = MESSAGE;
    }